# 修改说明：身份证号唯一性限制

## 修改日期
2025-12-07

## 问题描述
在原系统中，团报时即使有多个身份证号相同也能报名成功，这不符合实际业务需求。

## 解决方案
限制为：**同一个车次每个身份证号只能订一张票**

## 修改内容

### 1. 后端修改

#### 文件：`app/routes/ticket.py`
在 `book_ticket()` 函数中添加了两层身份证号验证：

1. **检查提交列表中的重复**：
   - 验证同一订单中是否有重复的身份证号
   - 如果有重复，立即返回错误信息

2. **检查数据库中的已存在记录**：
   - 查询该车次是否已有这些身份证号的有效票
   - 如果存在，返回具体的重复身份证号列表

```python
# 检查提交的乘客列表中是否有重复的身份证号
card_ids = [p['card_id'] for p in passengers]
if len(card_ids) != len(set(card_ids)):
    conn.rollback()
    return jsonify({'success': False, 'message': '同一订单中不能包含相同的身份证号'}), 400

# 检查这些身份证号是否已经在该车次订过票
check_card_sql = """
    SELECT card_id FROM Ticket 
    WHERE schedule_id = %s 
    AND card_id IN (...)
    AND status = 'valid'
"""
```

### 2. 数据库修改

#### 文件：`sql/add_card_unique_constraint.sql`
添加了新的唯一约束，确保数据库层面的数据完整性：

```sql
ALTER TABLE Ticket
ADD UNIQUE INDEX uk_schedule_card_valid (schedule_id, card_id, status);
```

**约束说明**：
- 包含 `status` 字段，因此退票后（status='refunded'）可以重新购买
- 与现有的 `uk_schedule_seat_valid` 约束共同作用，确保：
  - 同一座位在同一班次不能被重复售出
  - 同一身份证号在同一车次只能订一张票

**如何应用此迁移**：
```bash
# 在MySQL客户端或phpMyAdmin中执行
mysql -u用户名 -p < sql/add_card_unique_constraint.sql
```

或者：
```sql
-- 登录MySQL后执行
source /path/to/sql/add_card_unique_constraint.sql;
```

### 3. 前端修改

#### 文件：`app/templates/booking.html`

1. **表单提交前验证**：
   - 使用 `Set` 数据结构检查身份证号重复
   - 如果发现重复，显示友好的错误提示
   
```javascript
const cardIdSet = new Set();
for (let i = 0; i < selectedSeats.length; i++) {
    const cardId = ids[i].value.trim();
    
    if (cardIdSet.has(cardId)) {
        showMessage(`身份证号 ${cardId} 重复，同一订单中不能包含相同的身份证号`, 'warning');
        return;
    }
    cardIdSet.add(cardId);
}
```

2. **添加提示信息**：
   - 在"乘客信息"卡片标题处添加提示文字
   - 提醒用户：同一车次每个身份证号只能订一张票

### 4. 文档更新

#### `docs/数据库关系模式设计.md`
- 更新了 Ticket 表的索引说明
- 添加了新的唯一约束：`(schedule_id, card_id, status)`
- 更新了业务规则约束
- 完善了"防止超卖和重复订票"章节

#### `docs/系统功能实现描述.md`
- 更新了订票事务的实现代码
- 添加了身份证号验证的说明
- 列出了关键技术点

## 验证方法

### 前端验证
1. 打开订票页面，选择多个座位
2. 在不同的乘客表单中输入相同的身份证号
3. 点击"确认预订"
4. 应该看到提示："身份证号 xxx 重复，同一订单中不能包含相同的身份证号"

### 后端验证
1. 使用 API 测试工具（如 Postman）
2. 发送包含重复身份证号的订票请求：
```json
{
  "schedule_id": 1,
  "passengers": [
    {"name": "张三", "card_id": "110101199001011234", "seat_id": 1},
    {"name": "李四", "card_id": "110101199001011234", "seat_id": 2}
  ]
}
```
3. 应该收到错误响应：400 Bad Request

### 数据库验证
1. 应用迁移脚本后，检查索引是否创建成功：
```sql
SHOW INDEX FROM Ticket WHERE Key_name = 'uk_schedule_card_valid';
```

2. 尝试插入违反约束的数据：
```sql
-- 假设已存在一条记录
INSERT INTO Ticket (order_id, schedule_id, seat_id, passenger_name, card_id, price, status)
VALUES (1, 1, 2, '张三', '110101199001011234', 100.00, 'valid');

-- 尝试插入相同车次相同身份证号的记录
INSERT INTO Ticket (order_id, schedule_id, seat_id, passenger_name, card_id, price, status)
VALUES (2, 1, 3, '李四', '110101199001011234', 100.00, 'valid');

-- 应该报错：Duplicate entry for key 'uk_schedule_card_valid'
```

## 业务影响

### 正面影响
1. **防止恶意刷票**：避免同一人在同一车次订购多张票
2. **公平性**：确保每个乘客只能订一张票
3. **数据完整性**：数据库约束提供了额外的安全保障
4. **用户体验**：前端实时验证，避免无效提交

### 兼容性
1. **向后兼容**：现有的有效订单不受影响
2. **退票后可重购**：由于约束包含 status 字段，退票后可以重新购买
3. **个人订票**：不影响个人订票流程（只有一个乘客）

## 注意事项

1. **必须应用数据库迁移**：
   - 仅修改代码而不应用数据库迁移，系统仍可能允许重复订票（如果绕过应用层验证）
   - 应用迁移前，建议先检查是否存在违反约束的历史数据

2. **历史数据处理**：
   - 如果数据库中已存在违反约束的数据，迁移脚本会失败
   - 需要先手动处理这些数据（将部分票退票或修改身份证号）

3. **测试建议**：
   - 在测试环境先应用迁移并测试
   - 确认无问题后再在生产环境应用

## 回滚方案

如果需要回滚此修改：

### 1. 回滚数据库
```sql
ALTER TABLE Ticket DROP INDEX uk_schedule_card_valid;
```

### 2. 回滚代码
使用 Git 恢复到修改前的版本：
```bash
git checkout HEAD~1 app/routes/ticket.py
git checkout HEAD~1 app/templates/booking.html
```

## 相关文件清单

### 新增文件
- `sql/add_card_unique_constraint.sql` - 数据库迁移脚本
- `docs/修改说明-身份证号唯一性限制.md` - 本文档

### 修改文件
- `app/routes/ticket.py` - 后端订票逻辑
- `app/templates/booking.html` - 前端订票页面
- `docs/数据库关系模式设计.md` - 数据库设计文档
- `docs/系统功能实现描述.md` - 功能实现文档

## 总结

本次修改从**应用层（前端+后端）**和**数据库层**双重保障，确保同一车次每个身份证号只能订一张票。修改遵循了最佳实践：

1. ✅ 前端验证提升用户体验
2. ✅ 后端验证确保业务逻辑
3. ✅ 数据库约束保证数据完整性
4. ✅ 文档更新保持一致性
5. ✅ 向后兼容不影响现有数据
