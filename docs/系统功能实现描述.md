# 22306订票系统 - 系统功能实现描述

## 一、技术架构

### 1.1 技术栈
- **前端**：HTML5 + CSS3 + JavaScript（原生）
- **后端**：Python 3.x + Flask 2.3.3
- **数据库**：MySQL 8.0
- **其他**：bcrypt（密码加密）、pymysql（数据库连接）

### 1.2 项目结构
```
Project/
├── app/                      # 应用主目录
│   ├── __init__.py          # Flask应用初始化
│   ├── config.py            # 配置文件
│   ├── database.py          # 数据库连接管理
│   ├── routes/              # 路由模块
│   │   ├── __init__.py
│   │   ├── auth.py          # 认证路由
│   │   ├── ticket.py        # 售票路由
│   │   └── admin.py         # 管理员路由
│   ├── static/              # 静态资源
│   │   ├── css/
│   │   │   └── style.css
│   │   ├── js/
│   │   │   └── common.js
│   │   └── images/
│   └── templates/           # HTML模板
│       ├── index.html
│       ├── login.html
│       ├── register.html
│       ├── search.html
│       ├── booking.html
│       ├── my_orders.html
│       ├── admin.html
│       └── reset_password.html
├── docs/                    # 文档
├── sql/                     # SQL脚本
│   ├── create_tables.sql   # 建表脚本
│   └── init_data.sql       # 初始化数据
├── run.py                  # 入口程序
└── requirements.txt        # Python依赖
```

### 1.3 架构模式
- **MVC模式**：
  - Model：数据库表和SQL操作
  - View：HTML模板
  - Controller：Flask路由处理函数

## 二、主要功能模块实现

### 2.1 用户认证模块

#### 2.1.1 用户注册

**后端实现** (`app/routes/auth.py`):

```python
@auth_bp.route('/register', methods=['POST'])
def register():
    # 1. 获取并验证参数
    data = request.get_json()
    username = data['username']
    password = data['password']
    real_name = data['real_name']
    security_question = data['security_question']
    security_answer = data['security_answer']
    
    # 2. 检查用户名是否已存在
    existing_user = db.execute_query(
        "SELECT user_id FROM User WHERE username = %s",
        (username,), fetch_one=True
    )
    if existing_user:
        return jsonify({'success': False, 'message': '用户名已存在'}), 400
    
    # 3. 加密密码（bcrypt）
    hashed_password = bcrypt.hashpw(
        password.encode('utf-8'), 
        bcrypt.gensalt()
    ).decode('utf-8')
    
    # 4. 插入用户记录
    user_id = db.execute_insert(
        """INSERT INTO User (username, password, real_name, 
           security_question, security_answer, is_admin)
           VALUES (%s, %s, %s, %s, %s, FALSE)""",
        (username, hashed_password, real_name, 
         security_question, security_answer)
    )
    
    return jsonify({'success': True, 'user_id': user_id}), 201
```

**前端实现** (`app/templates/register.html`):

```javascript
document.getElementById('register-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    // 收集表单数据
    const username = document.getElementById('username').value;
    const password = document.getElementById('password').value;
    const confirmPassword = document.getElementById('confirm_password').value;
    
    // 前端验证
    if (password !== confirmPassword) {
        showMessage('两次密码输入不一致', 'warning');
        return;
    }
    
    // 发送注册请求
    const result = await apiRequest(`${API_BASE}/auth/register`, 'POST', {
        username, password, 
        real_name: realName,
        security_question: securityQuestion,
        security_answer: securityAnswer
    });
    
    if (result.success) {
        showMessage('注册成功！', 'success');
        window.location.href = '/login';
    }
});
```

**关键技术点**：
1. **密码加密**：使用bcrypt加密，防止明文存储
2. **参数验证**：前后端双重验证
3. **错误处理**：返回友好的错误消息

#### 2.1.2 用户登录

**后端实现**:

```python
@auth_bp.route('/login', methods=['POST'])
def login():
    # 1. 查询用户
    user = db.execute_query(
        """SELECT user_id, username, password, real_name, is_admin 
           FROM User WHERE username = %s""",
        (username,), fetch_one=True
    )
    
    # 2. 验证密码
    if not bcrypt.checkpw(password.encode('utf-8'), 
                          user['password'].encode('utf-8')):
        return jsonify({'success': False, 'message': '密码错误'}), 401
    
    # 3. 创建会话
    session_id = secrets.token_hex(32)
    token = secrets.token_hex(64)
    expire_time = datetime.now() + timedelta(seconds=3600)
    
    db.execute_insert(
        """INSERT INTO Session (session_id, user_id, login_time, 
           expire_time, token, device_info)
           VALUES (%s, %s, %s, %s, %s, %s)""",
        (session_id, user['user_id'], datetime.now(), 
         expire_time, token, request.user_agent.string)
    )
    
    # 4. 设置Flask session
    session['user_id'] = user['user_id']
    session['username'] = user['username']
    session['is_admin'] = bool(user['is_admin'])
    session['token'] = token
    
    return jsonify({'success': True, 'user': {...}})
```

**关键技术点**：
1. **会话管理**：使用Session表和Flask session双重管理
2. **令牌生成**：使用secrets模块生成安全的随机令牌
3. **过期时间**：设置1小时过期

### 2.2 车票查询模块

#### 2.2.1 多条件查询

**后端实现** (`app/routes/ticket.py`):

```python
@ticket_bp.route('/search', methods=['GET'])
def search_schedules():
    # 1. 获取查询参数
    date = request.args.get('date')
    start_city = request.args.get('start_city')
    end_city = request.args.get('end_city')
    schedule_no = request.args.get('schedule_no')
    
    # 2. 动态构建SQL（使用参数化防止SQL注入）
    sql = """
        SELECT 
            s.schedule_id, s.schedule_no, s.departure_date,
            s.departure_time, s.arrival_time, s.base_price,
            s.status, s.delay_minutes,
            r.route_name, st_start.station_name AS start_station,
            st_end.station_name AS end_station,
            v.seat_count - COALESCE(
                (SELECT COUNT(*) FROM Ticket t 
                 WHERE t.schedule_id = s.schedule_id 
                   AND t.status = 'valid'), 0
            ) AS available_seats
        FROM Schedule s
        JOIN Route r ON s.route_id = r.route_id
        JOIN Station st_start ON r.start_station_id = st_start.station_id
        JOIN Station st_end ON r.end_station_id = st_end.station_id
        JOIN Vehicle v ON s.vehicle_id = v.vehicle_id
        WHERE 1=1
    """
    
    params = []
    if date:
        sql += " AND s.departure_date = %s"
        params.append(date)
    if start_city:
        sql += " AND st_start.city LIKE %s"
        params.append(f'%{start_city}%')
    # ... 更多条件
    
    # 3. 执行查询
    results = db.execute_query(sql, params)
    
    return jsonify({'success': True, 'schedules': results})
```

**关键SQL技术**：
1. **多表JOIN**：关联Schedule、Route、Station、Vehicle表
2. **子查询计算余票**：`seat_count - (已售票数)`
3. **动态WHERE条件**：根据参数动态添加
4. **参数化查询**：防止SQL注入

**前端实现**:

```javascript
async function searchSchedules() {
    // 构建查询参数
    const params = new URLSearchParams();
    if (startCity) params.append('start_city', startCity);
    if (endCity) params.append('end_city', endCity);
    if (date) params.append('date', date);
    
    // 发送请求
    const result = await apiRequest(
        `${API_BASE}/ticket/search?${params.toString()}`
    );
    
    // 渲染结果表格
    if (result.success) {
        renderScheduleTable(result.schedules);
    }
}
```

### 2.3 订票模块

#### 2.3.1 座位选择

**后端实现**:

```python
@ticket_bp.route('/schedule/<int:schedule_id>/seats', methods=['GET'])
def get_available_seats(schedule_id):
    sql = """
        SELECT 
            s.seat_id, s.seat_no, s.seat_type, s.carriage_no,
            CASE 
                WHEN t.ticket_id IS NOT NULL THEN 'occupied'
                ELSE 'available'
            END AS seat_status
        FROM Seat s
        LEFT JOIN Ticket t ON s.seat_id = t.seat_id 
            AND t.schedule_id = %s 
            AND t.status = 'valid'
        WHERE s.vehicle_id = (
            SELECT vehicle_id FROM Schedule WHERE schedule_id = %s
        )
        ORDER BY s.carriage_no, s.seat_no
    """
    
    seats = db.execute_query(sql, (schedule_id, schedule_id))
    return jsonify({'success': True, 'seats': seats})
```

**前端实现**:

```javascript
function toggleSeat(element, available) {
    if (!available) return;
    
    const seatId = parseInt(element.dataset.seatId);
    
    if (element.classList.contains('selected')) {
        // 取消选择
        element.classList.remove('selected');
        selectedSeats = selectedSeats.filter(s => s.seat_id !== seatId);
    } else {
        // 选择座位
        element.classList.add('selected');
        selectedSeats.push({
            seat_id: seatId,
            seat_no: element.dataset.seatNo
        });
    }
    
    updatePassengerForms();  // 更新乘客表单
}
```

#### 2.3.2 订票事务

**后端实现**（使用悲观锁）:

```python
@ticket_bp.route('/book', methods=['POST'])
@require_login  # 登录装饰器
def book_ticket():
    conn = db.get_connection()
    cursor = conn.cursor()
    
    try:
        # 1. 开始事务
        conn.begin()
        
        # 2. 检查提交的乘客列表中是否有重复的身份证号
        card_ids = [p['card_id'] for p in passengers]
        if len(card_ids) != len(set(card_ids)):
            conn.rollback()
            return jsonify({'success': False, 'message': '同一订单中不能包含相同的身份证号'}), 400
        
        # 3. 检查这些身份证号是否已经在该车次订过票
        card_placeholders = ','.join(['%s'] * len(card_ids))
        check_card_sql = f"""
            SELECT card_id FROM Ticket 
            WHERE schedule_id = %s 
              AND card_id IN ({card_placeholders})
              AND status = 'valid'
        """
        cursor.execute(check_card_sql, [schedule_id] + card_ids)
        existing_cards = cursor.fetchall()
        
        if existing_cards:
            existing_card_list = ', '.join([c['card_id'] for c in existing_cards])
            conn.rollback()
            return jsonify({
                'success': False, 
                'message': f'身份证号 {existing_card_list} 已在该车次订票，每个身份证号只能订一张票'
            }), 400
        
        # 4. 锁定座位（FOR UPDATE悲观锁）
        seat_ids = [p['seat_id'] for p in passengers]
        placeholders = ','.join(['%s'] * len(seat_ids))
        
        check_sql = f"""
            SELECT seat_id FROM Ticket 
            WHERE schedule_id = %s 
              AND seat_id IN ({placeholders})
              AND status = 'valid'
            FOR UPDATE
        """
        cursor.execute(check_sql, [schedule_id] + seat_ids)
        occupied_seats = cursor.fetchall()
        
        # 5. 检查座位是否可用
        if occupied_seats:
            conn.rollback()
            return jsonify({'success': False, 'message': '座位已被占用'}), 400
        
        # 6. 创建订单
        cursor.execute(
            """INSERT INTO `Order` 
               (user_id, schedule_id, order_time, total_amount, 
                ticket_count, order_type, status)
               VALUES (%s, %s, %s, %s, %s, %s, 'confirmed')""",
            (user_id, schedule_id, datetime.now(), 
             total_amount, len(passengers), order_type)
        )
        order_id = cursor.lastrowid
        
        # 7. 创建车票（批量插入）
        for passenger in passengers:
            cursor.execute(
                """INSERT INTO Ticket 
                   (order_id, schedule_id, seat_id, passenger_name, 
                    card_id, price, status)
                   VALUES (%s, %s, %s, %s, %s, %s, 'valid')""",
                (order_id, schedule_id, passenger['seat_id'], 
                 passenger['name'], passenger['card_id'], base_price)
            )
        
        # 8. 提交事务
        conn.commit()
        
        return jsonify({'success': True, 'order_id': order_id})
        
    except Exception as e:
        conn.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500
    finally:
        cursor.close()
        conn.close()
```

**关键技术点**：
1. **身份证号验证**：
   - 检查同一订单中是否有重复身份证号
   - 检查数据库中该车次是否已有该身份证号的有效票
   - 防止团报时重复订票
2. **事务管理**：确保订单和车票同时成功或失败
3. **悲观锁**：使用FOR UPDATE锁定座位，防止并发超卖
4. **异常处理**：任何错误都回滚事务
5. **原子性**：订单和车票的创建是原子操作
6. **数据库约束**：Ticket表的(schedule_id, card_id, status)唯一索引提供额外保障

### 2.4 退票模块

**后端实现**:

```python
@ticket_bp.route('/refund', methods=['POST'])
@require_login
def refund_ticket():
    conn = db.get_connection()
    cursor = conn.cursor()
    
    try:
        conn.begin()
        
        # 1. 验证车票归属和状态（FOR UPDATE锁定）
        placeholders = ','.join(['%s'] * len(ticket_ids))
        check_sql = f"""
            SELECT t.ticket_id, t.order_id, t.price, t.status
            FROM Ticket t
            JOIN `Order` o ON t.order_id = o.order_id
            WHERE t.ticket_id IN ({placeholders})
              AND o.user_id = %s
            FOR UPDATE
        """
        cursor.execute(check_sql, ticket_ids + [user_id])
        tickets = cursor.fetchall()
        
        # 2. 检查状态
        for ticket in tickets:
            if ticket['status'] != 'valid':
                conn.rollback()
                return jsonify({'success': False, 
                              'message': '车票状态无效'}), 400
        
        # 3. 更新车票状态
        refund_amount = 0
        for ticket in tickets:
            cursor.execute(
                "UPDATE Ticket SET status = 'refunded' WHERE ticket_id = %s",
                (ticket['ticket_id'],)
            )
            
            # 4. 创建退票记录
            cursor.execute(
                """INSERT INTO Refund 
                   (ticket_id, refund_time, refund_amount, 
                    refund_reason, handled_by)
                   VALUES (%s, %s, %s, %s, %s)""",
                (ticket['ticket_id'], datetime.now(), ticket['price'], 
                 refund_reason, user_id)
            )
            
            refund_amount += float(ticket['price'])
        
        # 5. 更新订单状态（如果全部退票）
        if tickets:
            order_id = tickets[0]['order_id']
            cursor.execute(
                """SELECT COUNT(*) as total, 
                   SUM(CASE WHEN status = 'refunded' THEN 1 ELSE 0 END) as refunded
                   FROM Ticket WHERE order_id = %s""",
                (order_id,)
            )
            result = cursor.fetchone()
            
            if result['total'] == result['refunded']:
                cursor.execute(
                    "UPDATE `Order` SET status = 'refunded' WHERE order_id = %s",
                    (order_id,)
                )
        
        conn.commit()
        
        return jsonify({'success': True, 'refund_amount': refund_amount})
        
    except Exception as e:
        conn.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500
    finally:
        cursor.close()
        conn.close()
```

**关键技术点**：
1. **权限验证**：确保用户只能退自己的票
2. **状态检查**：只能退有效车票
3. **记录保留**：创建退票记录，不删除原始数据
4. **级联更新**：如果订单所有票都退，更新订单状态

### 2.5 管理员模块

#### 2.5.1 班次管理

**添加班次**:

```python
@admin_bp.route('/schedule/add', methods=['POST'])
@require_admin  # 管理员权限装饰器
def add_schedule():
    data = request.get_json()
    
    schedule_id = db.execute_insert(
        """INSERT INTO Schedule 
           (schedule_no, route_id, vehicle_id, departure_date, 
            departure_time, arrival_time, base_price, status, delay_minutes)
           VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)""",
        (data['schedule_no'], data['route_id'], data['vehicle_id'], 
         data['departure_date'], data['departure_time'], data['arrival_time'],
         data['base_price'], data.get('status', 'normal'), 
         data.get('delay_minutes', 0))
    )
    
    # 记录操作日志
    log_admin_operation('ADD_SCHEDULE', f"添加班次: {data['schedule_no']}", 
                       'Schedule', schedule_id)
    
    return jsonify({'success': True, 'schedule_id': schedule_id})
```

**批量更新票价**:

```python
@admin_bp.route('/schedule/batch_update_price', methods=['POST'])
@require_admin
def batch_update_price():
    data = request.get_json()
    
    # 更新同一线路的所有班次票价
    affected = db.execute_update(
        """UPDATE Schedule s
           JOIN Route r ON s.route_id = r.route_id
           SET s.base_price = %s
           WHERE r.start_station_id = %s AND r.end_station_id = %s""",
        (data['new_price'], data['start_station_id'], data['end_station_id'])
    )
    
    log_admin_operation('BATCH_UPDATE_PRICE', 
                       f"批量更新票价，影响{affected}条记录")
    
    return jsonify({'success': True, 'affected': affected})
```

#### 2.5.2 报表系统

**销售报表**:

```python
@admin_bp.route('/report/sales', methods=['GET'])
@require_admin
def get_sales_report():
    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')
    
    sql = """
        SELECT 
            DATE(o.order_time) as order_date,
            COUNT(DISTINCT o.order_id) as order_count,
            SUM(o.ticket_count) as ticket_count,
            SUM(o.total_amount) as total_sales,
            COUNT(DISTINCT CASE WHEN o.order_type = 'group' 
                  THEN o.order_id END) as group_order_count
        FROM `Order` o
        WHERE o.status IN ('confirmed', 'refunded')
          AND o.order_time >= %s
          AND o.order_time <= %s
        GROUP BY DATE(o.order_time)
        ORDER BY order_date DESC
    """
    
    results = db.execute_query(sql, (start_date, end_date + ' 23:59:59'))
    
    return jsonify({'success': True, 'report': results})
```

**报表导出（CSV）**:

```python
@admin_bp.route('/report/export', methods=['GET'])
@require_admin
def export_report():
    # 查询综合数据
    sql = """
        SELECT 
            o.order_id, u.username, u.real_name,
            s.schedule_no, r.route_name,
            st_start.station_name AS start_station,
            st_end.station_name AS end_station,
            s.departure_date, s.departure_time,
            o.order_time, o.ticket_count, o.total_amount,
            o.order_type, o.status
        FROM `Order` o
        JOIN User u ON o.user_id = u.user_id
        JOIN Schedule s ON o.schedule_id = s.schedule_id
        JOIN Route r ON s.route_id = r.route_id
        JOIN Station st_start ON r.start_station_id = st_start.station_id
        JOIN Station st_end ON r.end_station_id = st_end.station_id
        ORDER BY o.order_time DESC
        LIMIT 1000
    """
    
    results = db.execute_query(sql)
    
    # 返回JSON，前端转换为CSV下载
    return jsonify({'success': True, 'data': results})
```

## 三、数据库连接管理

**连接池实现** (`app/database.py`):

```python
class Database:
    @staticmethod
    @contextmanager
    def get_cursor(commit=True):
        """上下文管理器，自动管理连接和事务"""
        conn = Database.get_connection()
        cursor = conn.cursor()
        try:
            yield cursor
            if commit:
                conn.commit()
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            cursor.close()
            conn.close()
```

**使用示例**:

```python
# 自动提交
with Database.get_cursor(commit=True) as cursor:
    cursor.execute("INSERT INTO ...")

# 只查询，不提交
with Database.get_cursor(commit=False) as cursor:
    cursor.execute("SELECT ...")
    results = cursor.fetchall()
```

## 四、前端技术实现

### 4.1 AJAX请求封装

```javascript
async function apiRequest(url, method = 'GET', data = null) {
    const options = {
        method: method,
        headers: {'Content-Type': 'application/json'},
        credentials: 'include'  // 包含cookie（session）
    };
    
    if (data && method !== 'GET') {
        options.body = JSON.stringify(data);
    }
    
    const response = await fetch(url, options);
    return await response.json();
}
```

### 4.2 消息提示

```javascript
function showMessage(message, type = 'info') {
    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${type}`;
    alertDiv.textContent = message;
    // ... 动画效果
    document.body.appendChild(alertDiv);
    
    setTimeout(() => {
        // 自动消失
    }, 3000);
}
```

### 4.3 导航栏动态更新

```javascript
async function initNavbar() {
    const user = await getCurrentUser();
    const userInfoDiv = document.getElementById('user-info');
    
    if (user) {
        userInfoDiv.innerHTML = `
            <span>欢迎，${user.username}</span>
            <button onclick="logout()">退出</button>
        `;
        
        // 如果是管理员，显示管理员菜单
        if (user.is_admin) {
            document.querySelector('a[href="/admin"]').style.display = 'block';
        }
    } else {
        userInfoDiv.innerHTML = `
            <a href="/login">登录</a>
            <a href="/register">注册</a>
        `;
    }
}
```

## 五、安全措施

### 5.1 后端安全

1. **SQL注入防护**：使用参数化查询
2. **密码加密**：bcrypt加密
3. **权限验证**：装饰器验证登录和管理员权限
4. **会话管理**：Flask session + 数据库Session表

### 5.2 前端安全

1. **输入验证**：前端验证数据格式
2. **XSS防护**：使用textContent而非innerHTML
3. **CSRF防护**：Flask自带CSRF保护

## 六、总结

本系统采用前后端分离架构，后端提供RESTful API，前端使用AJAX调用。主要技术亮点：

1. **数据库事务**：确保订票、退票的原子性
2. **并发控制**：悲观锁防止超卖
3. **密码安全**：bcrypt加密
4. **会话管理**：双重会话机制
5. **权限控制**：装饰器模式
6. **日志记录**：管理员操作审计
7. **报表功能**：多维度统计分析

