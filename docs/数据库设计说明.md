# 22306订票系统 - 数据库设计说明

## 一、索引设计

### 1.1 索引设计原则
1. **主键索引**：所有表都使用自增主键，自动创建聚集索引
2. **唯一索引**：用于保证数据唯一性（用户名、车辆编号等）
3. **外键索引**：所有外键字段都建立索引，提高JOIN性能
4. **查询优化索引**：根据高频查询条件建立索引

### 1.2 关键索引列表

#### User表
```sql
-- 主键索引
PRIMARY KEY (user_id)

-- 唯一索引
UNIQUE INDEX idx_username (username)

-- 普通索引
INDEX idx_real_name (real_name)  -- 支持按姓名查询订单
```

#### Schedule表
```sql
-- 主键索引
PRIMARY KEY (schedule_id)

-- 唯一索引（防止同一班次同一天重复）
UNIQUE INDEX uk_schedule_date (schedule_no, departure_date)

-- 外键索引
INDEX idx_route_id (route_id)
INDEX idx_vehicle_id (vehicle_id)

-- 查询优化索引
INDEX idx_departure_date (departure_date)  -- 按日期查询
INDEX idx_status (status)  -- 按状态筛选
```

#### Order表
```sql
-- 主键索引
PRIMARY KEY (order_id)

-- 外键索引
INDEX idx_user_id (user_id)      -- 查询用户订单
INDEX idx_schedule_id (schedule_id)

-- 查询优化索引
INDEX idx_order_time (order_time)  -- 按时间排序
INDEX idx_status (status)          -- 按状态筛选
```

#### Ticket表
```sql
-- 主键索引
PRIMARY KEY (ticket_id)

-- 唯一索引（防止同一座位同一班次被重复售出）
UNIQUE INDEX uk_schedule_seat_valid (schedule_id, seat_id, status)

-- 外键索引
INDEX idx_order_id (order_id)
INDEX idx_schedule_id (schedule_id)
INDEX idx_seat_id (seat_id)

-- 查询优化索引
INDEX idx_passenger_name (passenger_name)
INDEX idx_card_id (card_id)
INDEX idx_status (status)
```

### 1.3 索引使用建议

**适合使用索引的场景**：
- WHERE子句中的过滤条件
- JOIN连接条件
- ORDER BY排序字段
- GROUP BY分组字段

**不适合使用索引的场景**：
- 数据量很小的表
- 频繁更新的字段
- 选择性很低的字段（如性别）

## 二、并发控制设计

### 2.1 事务隔离级别

使用 **READ COMMITTED** 隔离级别：
- 防止脏读
- 允许不可重复读
- 性能和一致性的平衡

### 2.2 订票并发控制

#### 方案一：悲观锁（推荐）

```sql
START TRANSACTION;

-- 1. 锁定要购买的座位（FOR UPDATE）
SELECT seat_id 
FROM Seat 
WHERE vehicle_id = ? 
  AND seat_id IN (?, ?, ...)
  AND seat_id NOT IN (
      SELECT seat_id 
      FROM Ticket 
      WHERE schedule_id = ? 
        AND status = 'valid'
  )
FOR UPDATE;

-- 2. 检查座位是否足够
-- 如果不足，ROLLBACK

-- 3. 创建订单
INSERT INTO `Order` (...) VALUES (...);

-- 4. 创建车票
INSERT INTO Ticket (...) VALUES (...);

COMMIT;
```

**优点**：
- 完全避免超卖
- 数据强一致性

**缺点**：
- 并发性能稍低
- 可能产生锁等待

#### 方案二：乐观锁

为Seat表添加version字段：

```sql
-- 读取座位信息
SELECT seat_id, version 
FROM Seat 
WHERE seat_id = ?;

-- 更新时检查version
UPDATE Seat 
SET version = version + 1 
WHERE seat_id = ? 
  AND version = ?;

-- 如果affected_rows = 0，说明冲突，重试
```

**优点**：
- 并发性能高
- 无锁等待

**缺点**：
- 需要重试机制
- 高并发下重试次数多

### 2.3 数据库约束防止超卖

```sql
-- Ticket表的唯一约束
UNIQUE INDEX uk_schedule_seat_valid (schedule_id, seat_id, status)
```

这个约束确保：
- 同一个座位
- 在同一个班次
- 状态为valid的票

只能存在一条记录。即使应用层逻辑有问题，数据库也会拒绝插入重复记录。

### 2.4 死锁处理

**死锁预防**：
1. 按固定顺序锁定资源
2. 缩短事务时间
3. 使用较低的隔离级别

**死锁检测**：
- MySQL自动检测死锁
- 自动回滚其中一个事务

**应用层处理**：
```python
try:
    # 执行事务
    conn.begin()
    # ...
    conn.commit()
except pymysql.err.OperationalError as e:
    if e.args[0] == 1213:  # Deadlock
        # 重试逻辑
        time.sleep(random.uniform(0.01, 0.1))
        retry()
    else:
        raise
```

## 三、性能优化技巧

### 3.1 查询优化

#### 使用EXPLAIN分析查询
```sql
EXPLAIN SELECT * FROM Schedule WHERE departure_date = '2025-12-06';
```

#### 避免SELECT *
```sql
-- 不好
SELECT * FROM Ticket WHERE order_id = 1;

-- 好
SELECT ticket_id, passenger_name, seat_id, price 
FROM Ticket WHERE order_id = 1;
```

#### 使用覆盖索引
```sql
-- 如果查询只需要索引中的列，可以避免回表
SELECT user_id, order_time, status 
FROM `Order` 
WHERE status = 'confirmed';
```

#### 优化JOIN
```sql
-- 使用INNER JOIN代替子查询
SELECT o.*, s.schedule_no 
FROM `Order` o
INNER JOIN Schedule s ON o.schedule_id = s.schedule_id
WHERE o.user_id = ?;
```

### 3.2 数据库连接池

使用连接池减少连接开销：

```python
from DBUtils.PooledDB import PooledDB

pool = PooledDB(
    creator=pymysql,
    maxconnections=20,
    mincached=2,
    maxcached=5,
    blocking=True,
    host='localhost',
    user='root',
    password='123456',
    database='ticket_system',
    charset='utf8mb4'
)
```

### 3.3 分区表（可选）

对于大数据量的表，可以按时间分区：

```sql
-- Order表按月分区
ALTER TABLE `Order` 
PARTITION BY RANGE (YEAR(order_time) * 100 + MONTH(order_time)) (
    PARTITION p202501 VALUES LESS THAN (202502),
    PARTITION p202502 VALUES LESS THAN (202503),
    PARTITION p202503 VALUES LESS THAN (202504),
    -- ...
    PARTITION pmax VALUES LESS THAN MAXVALUE
);
```

### 3.4 缓存策略

#### 应用层缓存（Redis）

```python
import redis

# 缓存车站列表（很少变化）
cache = redis.Redis(host='localhost', port=6379)

def get_stations():
    # 先从缓存读取
    cached = cache.get('stations')
    if cached:
        return json.loads(cached)
    
    # 缓存未命中，从数据库读取
    stations = db.execute_query("SELECT * FROM Station")
    
    # 写入缓存，过期时间1小时
    cache.setex('stations', 3600, json.dumps(stations))
    
    return stations
```

#### 查询结果缓存

对于热门查询，可以缓存查询结果：

```python
def search_schedules(date, start_city, end_city):
    cache_key = f"schedules:{date}:{start_city}:{end_city}"
    
    cached = cache.get(cache_key)
    if cached:
        return json.loads(cached)
    
    results = db.execute_query(...)
    cache.setex(cache_key, 300, json.dumps(results))  # 5分钟
    
    return results
```

### 3.5 批量操作

```python
# 批量插入车票
cursor.executemany(
    "INSERT INTO Ticket (...) VALUES (%s, %s, %s, ...)",
    [(order_id, schedule_id, seat_id, ...) for ... in passengers]
)
```

## 四、备份与恢复

### 4.1 备份策略

#### 全量备份
```bash
# 每日凌晨2点全量备份
mysqldump -u root -p123456 ticket_system > backup_$(date +%Y%m%d).sql
```

#### 增量备份
```bash
# 启用binlog
# my.cnf配置
[mysqld]
log-bin=mysql-bin
binlog_format=ROW
expire_logs_days=7

# 每小时备份binlog
mysqlbinlog mysql-bin.000001 > binlog_backup_$(date +%Y%m%d_%H).sql
```

### 4.2 恢复操作

```bash
# 恢复全量备份
mysql -u root -p123456 ticket_system < backup_20251206.sql

# 恢复增量备份
mysqlbinlog binlog_backup_*.sql | mysql -u root -p123456
```

## 五、读写分离（可选）

对于高并发场景，可以配置主从复制：

### 5.1 主从架构

```
Master (写)
  ↓ 复制
Slave1 (读)
Slave2 (读)
```

### 5.2 应用层路由

```python
class DatabaseRouter:
    def get_connection(self, write=False):
        if write:
            return get_master_connection()
        else:
            return get_slave_connection()

# 写操作使用主库
conn = router.get_connection(write=True)
cursor = conn.cursor()
cursor.execute("INSERT INTO ...")

# 读操作使用从库
conn = router.get_connection(write=False)
cursor = conn.cursor()
cursor.execute("SELECT ...")
```

## 六、监控与维护

### 6.1 性能监控

#### 慢查询日志
```sql
-- my.cnf配置
[mysqld]
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 2

-- 分析慢查询
mysqldumpslow /var/log/mysql/slow.log
```

#### 性能指标监控
```sql
-- 查看当前连接数
SHOW STATUS LIKE 'Threads_connected';

-- 查看查询缓存命中率
SHOW STATUS LIKE 'Qcache%';

-- 查看表锁情况
SHOW STATUS LIKE 'Table_locks%';

-- 查看InnoDB缓冲池
SHOW STATUS LIKE 'Innodb_buffer_pool%';
```

### 6.2 定期维护

#### 优化表
```sql
-- 优化表，整理碎片
OPTIMIZE TABLE `Order`;
OPTIMIZE TABLE Ticket;
```

#### 分析表
```sql
-- 更新统计信息
ANALYZE TABLE Schedule;
```

#### 检查表
```sql
-- 检查表是否损坏
CHECK TABLE User;
```

### 6.3 清理过期数据

```sql
-- 清理过期会话（每天执行）
DELETE FROM Session WHERE expire_time < NOW();

-- 归档历史订单（每月执行）
INSERT INTO Order_Archive 
SELECT * FROM `Order` 
WHERE order_time < DATE_SUB(NOW(), INTERVAL 6 MONTH);

DELETE FROM `Order` 
WHERE order_time < DATE_SUB(NOW(), INTERVAL 6 MONTH);
```

## 七、安全设计

### 7.1 SQL注入防护

**使用参数化查询**：
```python
# 安全
cursor.execute(
    "SELECT * FROM User WHERE username = %s", 
    (username,)
)

# 危险
cursor.execute(
    f"SELECT * FROM User WHERE username = '{username}'"
)
```

### 7.2 权限管理

```sql
-- 创建只读用户
CREATE USER 'report_user'@'localhost' IDENTIFIED BY 'password';
GRANT SELECT ON ticket_system.* TO 'report_user'@'localhost';

-- 创建应用用户
CREATE USER 'app_user'@'localhost' IDENTIFIED BY 'password';
GRANT SELECT, INSERT, UPDATE, DELETE ON ticket_system.* TO 'app_user'@'localhost';

-- 刷新权限
FLUSH PRIVILEGES;
```

### 7.3 敏感数据加密

```python
import bcrypt

# 密码加密
hashed = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())

# 密码验证
if bcrypt.checkpw(password.encode('utf-8'), hashed):
    # 验证成功
    pass
```

## 八、扩展性设计

### 8.1 垂直扩展
- 增加服务器CPU、内存、磁盘
- 使用SSD提高I/O性能
- 调整MySQL配置参数

### 8.2 水平扩展
- 主从复制（读写分离）
- 分库分表（按地区、按时间）
- 中间件（MyCAT、Sharding-JDBC）

### 8.3 数据库配置优化

```ini
[mysqld]
# InnoDB缓冲池大小（物理内存的50-80%）
innodb_buffer_pool_size = 2G

# 连接数
max_connections = 500

# 查询缓存
query_cache_size = 128M
query_cache_type = 1

# 日志
log_bin = mysql-bin
binlog_format = ROW

# 其他
innodb_flush_log_at_trx_commit = 2
innodb_log_file_size = 256M
```

## 九、总结

本系统数据库设计遵循以下原则：
1. **规范化**：符合第三范式，减少数据冗余
2. **完整性**：通过约束保证数据一致性
3. **性能**：合理使用索引，优化查询
4. **并发**：使用事务和锁机制防止冲突
5. **安全**：参数化查询、权限管理、数据加密
6. **可维护**：日志记录、备份恢复、监控告警
7. **可扩展**：支持分区、分库、读写分离

